
"""
    Fixes to make:
        - remove ';' in the last port when building code to avoid VHDL syntax error [_solved_]

    Notes :
        - find a better way to handle python errors or a way to generate custom errors
            (see try-except)
"""
from pathlib import Path
from .port import Port
import os

class Entity:
    # constants : should be saved in VHDL
    library      = {'ieee'  :           'library ieee;\n'}
    use          = {'std_logic_1164' :  'use ieee.std_logic_1164.all;\n'}

    entity       = {'open'  :           'entity {name} is\n',
                    'end'   :           'end entity {name};\n\n'}
    generic      = {'open'  :           '  generic(\n',
                    'map'   :           '  generic map(\n',
                    'end'   :           '  );\n'}

    port         = {'open'  :           '  port(\n',
                    'map'   :           '  port map(\n',
                    'end'   :           '  );\n'}

    component    = {'open'  :           '  component {name} is\n',
                    'end'   :           '  end component {name};\n\n'}

    instance     = {'open'  :           '  {i_name} : {e_name}\n',
                    'map'   :           '    {i_port} => {connect_to},\n',
                    'end'   :           '  );\n\n'}

    architecture = {'open'  :           'architecture {name}_arch of {name} is\n\n',
                    'begin' :           '\nbegin\n\n',
                    'end'   :           'end architecture;\n'}
    directory    = r"VHDL_codes"

    def __init__(self, entity_name = '', circuit_type = None):
        self.__entity_name = entity_name
        self.__vhdl_code = []
        self.__generics = {} # {'val_name' : (val_name,val_type)}
        self.__ports = {} # {'port_name' : Port}
        self.__number_of_inputs = 0
        self.__number_of_outputs = 0
        self.__components = {} # {"entity_name" : (Entity, instances)}
        self.__declared_signals = set() # using sets to avoid duplicates

    def reset(self):
        self.__entity_name = ''
        self.__vhdl_code = []
        self.__generics = {} # {'val_name' : (val_name,val_type)}
        self.__ports = {} # {'port_name' : Port}
        self.__number_of_inputs = 0
        self.__number_of_outputs = 0
        self.__components = {} # {"entity_name" : (Entity, instances)}
        self.__declared_signals = set() # using sets to avoid duplicates

    ### Set Methods ######################################################################
    def set_entity_name(self,name):
        self.__entity_name = name

    ### Get methods ######################################################################
    def get_entity_name(self): return self.__entity_name
    def get_port(self, port): return self.__ports[port]
    def get_ports(self): return self.__ports
    def get_generics(self): return self.__generics
    def get_components(self): return self.__components

    def get_code(self):
        if len(self.__vhdl_code) == 0:
            return 'Null'
        else:
            return ''.join([str(item) for item in self.__vhdl_code])

    def get_component(self,entity):
        if entity.get_entity_name() in list(self.__components.keys()):
            entity_name = entity.get_entity_name()
            comp,instances = self.__components[entity_name]
            return comp

    ### Add methods ######################################################################
    def add_generics(self,val_name,val_type): self.__generics[val_name] = val_name,val_type
    def add_line(self, s): self.__vhdl_code.append(s)

    def add_port(self, port):
        self.__ports[port.get_port_name()] = port
        if port.get_direction() == "in" :
            self.__number_of_inputs += 1;
        elif port.get_direction() == "out":
            self.__number_of_outputs += 1;

    def add_component(self, entity):
        entity_name = entity.get_entity_name()
        self.__components[entity_name] = entity,0

    ### Build code method ################################################################
    def __build_code(self, file_name = None):
        if file_name == None:
            name_placeholder = self.__entity_name
        else:
            name_placeholder = file_name

        script_sign = '-- -=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=- --\n'\
                      '--     Code generated by VGen by Christian Manuel    --\n'\
                      '-- -=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=- --\n'
        self.add_line(script_sign)
        self.add_line(Entity.library['ieee'])
        self.add_line(Entity.use['std_logic_1164'])
        self.add_line('\n')
        self.add_line(Entity.entity['open'].format(name = name_placeholder))

        # add generics if theres any
        generics = self.get_generics()
        if len(generics) != 0:
            self.add_line(Entity.generic['open'])
            for index,(val_name,val_type) in enumerate(generics.values()):
                if index == len(generics) - 1:
                    self.add_line(f'    {val_name} : {val_type}\n')
                else:
                    self.add_line(f'    {val_name} : {val_type};\n')
            self.add_line(Entity.generic['end'])

        ports = self.get_ports()
        # write entity ports if there are any
        if  len(ports) != 0:
            self.add_line(Entity.port['open'])
            for index,(port_name,port) in enumerate(ports.items()):
                if index == len(ports) - 1:
                    self.add_line(port.get_line().replace(';',''))
                else:
                    self.add_line(port.get_line())
            self.add_line(Entity.port['end'])
        self.add_line(Entity.entity['end'].format(name = self.get_entity_name()))
        self.add_line(Entity.architecture['open'].format(name = name_placeholder))

        components = self.get_components()
        # component declarations
        if len(components) != 0:
            for component_name,(component,number_of_instances) in components.items():
                component_ports = component.get_ports()
                component_generics = component.get_generics()
                self.add_line(Entity.component['open'].format(name = component_name))

                # generics
                if len(component_generics) != 0:
                    self.add_line(Entity.generic['open'])
                    for index,(val_name,val_type) in enumerate(component_generics.values()):
                        if index == len(component_generics) - 1:
                            self.add_line(f'    {val_name} : {val_type}\n')
                        else:
                            self.add_line(f'    {val_name} : {val_type};\n')
                    self.add_line(Entity.generic['end'])

                # component ports
                if len(component_ports) != 0:  # skip if no ports
                    self.add_line(Entity.port['open'])
                    for index,(port_name,port) in enumerate(list(component_ports.items())):
                        if index == len(component_ports) - 1:
                            self.add_line(port.get_line().replace(';',''))
                        else:
                            self.add_line(port.get_line())
                    self.add_line(Entity.port['end'])
                self.add_line(Entity.component['end'].format(name = component_name))

        # signal declerations
        for component_name,(component,number_of_instances) in components.items():
            component_ports = component.get_ports()
            self.add_line(f'  -- {component_name}\n')
            for port_name, port in component_ports.items():
                # the declared signals are ordered in a way that only the outputs for each block are declared
                if (port_name not in self.__declared_signals) and (port.get_direction() == 'out'):
                    if type(port.get_length()) == type(1):
                        if port.get_length() > 1:
                            s = f'  signal {port_name} : {port.get_type()}({port.get_length()-1} downto 0);\n'
                        else:
                            s = f'  signal {port_name} : {port.get_type()};\n'
                    else:
                        s = f'  signal {port_name} : {port.get_type()}({port.get_length()} downto 0);\n'
                    self.add_line(s)
                    self.__declared_signals.add(port_name)

        # architecture begin
        self.add_line(Entity.architecture['begin'])

        # instantiations
        for component_name,(component,number_of_instances) in components.items():
            component_ports = component.get_ports()
            component_generics = component.get_generics()
            if len(component_ports) != 0:
                if number_of_instances != 0:
                    for i in range(number_of_instances):
                        # {instance name} : {component to instance}
                        self.add_line(Entity.instance['open'].format(i_name = f'{component_name}_{i}_i', e_name = component_name))
                        # generic mapping
                        if len(component_generics) != 0:
                            self.add_line(Entity.generic['map'])
                            for index, (val_name,val_type) in enumerate(list(component_generics.values())):
                                s = Entity.instance['map'].format(i_port = val_name, connect_to = 'open')
                                if index == len(component_generics) - 1:
                                    self.add_line(s.replace(',',''))
                                else:
                                    self.add_line(s)
                            self.add_line(Entity.generic['end'])
                        # port mapping
                        self.add_line(Entity.port['map'])
                        for index,(port_name,port) in enumerate(list(component_ports.items())):
                            port_connections = port.get_connections()
                            # {instance_port} => {signal/port}
                            if 'out' == port.get_direction():
                                s = Entity.instance['map'].format(i_port = port_name, connect_to = port_name)
                            elif len(port_connections) != 0: # if input is connected, connect to port
                                port_b = list(port_connections.values())
                                s = Entity.instance['map'].format(i_port = port_name, connect_to = port_b[0].get_port_name())
                            else:
                                s = Entity.instance['map'].format(i_port = port_name, connect_to = 'open')

                            if index == len(component_ports) - 1:
                                self.add_line(s.replace(',',''))
                            else:
                                self.add_line(s)

                        self.add_line(Entity.instance['end'])
                        print(f"{component_name}_{i}_i instanced!")

        self.add_line(Entity.architecture['end'])

    ### functional methods ###############################################################
    def show_code(self): print(self.get_code())
    def clear_code(self): self.__vhdl_code = []

    def show_components(self):
        if len(self.__components) != 0:
            print(f"\nDeclared components :\n")
            for component,instances in self.__components.values():
                s = f' {component.get_entity_name()}, {instances} instances'
                print(s)
            print('')
        else:
            print('no components')

    def connect(self, port_a, entity_b, port_b):
        if port_a.get_port_name() in self.__ports.keys():
            port_a.connect_port(entity_b,port_b)
        else:
            print(f'{port.get_port_name()} not present')


    def instantiate(self,entity, num_of_instances = 0):
        if entity.get_entity_name() in list(self.__components.keys()):
            comp, instances = self.__components[entity.get_entity_name()]
            N = instances+1 if num_of_instances == 0 else instances + num_of_instances
            self.__components[entity.get_entity_name()] = comp,N
        else:
            print('component hasn\'t been declared')

    def generate_netlist(self):
        pass

    def generate_code(self, name = None):
        fname = self.__entity_name + '.vhd' if name == None else name + '.vhd'
        complete_path = os.path.join(Entity.directory, fname)
        self.__build_code(name)

        if not self.__check_file(complete_path):
            with open(complete_path, mode = 'w') as file:
                file.write(self.get_code())
        else:
            print(f'Failed to generate code : file \'{fname}\' already exists...')

    def __check_file(self,path):
        file = Path(path)
        return file.is_file()

# print(__name__)
