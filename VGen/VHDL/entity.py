
"""
    Fixes to make:
        - remove ';' in the last port when building code to avoid VHDL syntax error [_solved_]

    Notes :
        - find a better way to handle python errors or a way to generate custom errors
            (see try-except)
"""
from pathlib import Path
from .port import Port
import os

class Entity:
    # constants : should be saved in VHDL
    library      = {'ieee'  :           'library ieee;\n'}
    use          = {'std_logic_1164' :  'use ieee.std_logic_1164.all;\n'}

    entity       = {'open'  :           'entity {name} is\n',
                    'end'   :           'end entity {name};\n\n'}
    generic      = {'open'  :           '  generic(\n',
                    'map'   :           '  generic map(\n',
                    'end'   :           '  );\n'}

    port         = {'open'  :           '  port(\n',
                    'map'   :           '  port map(\n',
                    'end'   :           '  );\n'}

    component    = {'open'  :           '  component {name} is\n',
                    'end'   :           '  end component {name};\n\n'}

    instance     = {'open'  :           '  {i_name} : {e_name}\n',
                    'map'   :           '    {i_port} => {connect_to},\n',
                    'end'   :           '  );\n\n'}

    architecture = {'open'  :           'architecture {name}_arch of {name} is\n\n',
                    'begin' :           '\nbegin\n\n',
                    'end'   :           'end architecture;\n'}
    directory    = r"VHDL_codes"

    def __init__(self, entity_name, circuit_type = None):
        self.__entity_name = entity_name
        self.__vhdl_code = []
        self.__generics = {} # {'val_name' : (val_name,val_type)}
        self.__ports = {} # dictionary, associate port name with port lines
        self.__number_of_inputs = 0
        self.__number_of_outputs = 0
        # {"entity_name" : (Entity, instances)}
        self.__components = {} # dictionary of entities
        self.__declared_signals = set()
        self.__isPrimitive = True # if True, no need for component declarations or instantiations

    def get_entity_name(self):
        return self.__entity_name

    def get_ports(self):
        return self.__ports

    def get_generics(self):
        return self.__generics

    def get_code(self):
        if len(self.__vhdl_code) == 0:
            return 'Null'
        else:
            return ''.join([str(item) for item in self.__vhdl_code])

    def add_generics(self,val_name,val_type):
        self.__generics[val_name] = val_name,val_type


    def add_port(self, port):
        self.__ports[port.get_port_name()] = port
        if port.get_direction() == "in" :
            self.__number_of_inputs += 1;
        elif port.get_direction() == "out":
            self.__number_of_outputs += 1;

    def get_component(self,entity):
        if entity.get_entity_name() in list(self.__components.keys()):
            entity_name = entity.get_entity_name()
            comp,instances = self.__components[entity_name]
            return comp


    # returns a list of tuple pairs entity,instances
    def get_components(self):
        return self.__components

    """
        Can add the import function to this
    """
    def add_ports(self, num_of_inputs = 1, num_of_outputs = 1):
        for i in range(num_of_inputs):
            self.add_port(Port(f'input_{i}','in',1))
            self.__number_of_inputs += 1

        for i in range(num_of_outputs):
            self.add_port(Port(f'output_{i}','out',1))
            self.__number_of_outputs += 1

    def add_component(self, entity):
        entity_name = entity.get_entity_name()
        self.__components[entity_name] = entity,0


    def instantiate(self,entity, num_of_instances = 0):
        if entity.get_entity_name() in list(self.__components.keys()):
            comp, instances = self.__components[entity.get_entity_name()]

            if num_of_instances == 0:
                N = instances + 1
            else:
                N = instances + num_of_instances

            self.__components[entity.get_entity_name()] = comp,N
        #     print("instantiated!")
        else:
            print('component hasn\'t been declared')

    def remove_port(self):
        pass

    def add_line(self, s):
        self.__vhdl_code.append(s)

    def __build_code(self, file_name = None):
        if file_name == None:
            name_placeholder = self.__entity_name
        else:
            name_placeholder = file_name

        script_sign = '-- -=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=- --\n'\
                      '--     Code generated by VGen by Christian Manuel    --\n'\
                      '-- -=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=-=#=- --\n'
        self.add_line(script_sign)

        self.add_line(Entity.library['ieee'])
        self.add_line(Entity.use['std_logic_1164'])
        self.add_line('\n')
        self.add_line(Entity.entity['open'].format(name = name_placeholder))

        # add generics if theres any
        generics = self.get_generics()
        if len(generics) != 0:
            self.add_line(Entity.generic['open'])
            for index,(val_name,val_type) in enumerate(generics.values()):

                if index == len(generics) - 1:
                    self.add_line(f'    {val_name} : {val_type}\n')
                else:
                    self.add_line(f'    {val_name} : {val_type};\n')

            self.add_line(Entity.generic['end'])

        ports = self.get_ports()
        # write entity ports if there are any
        if  len(ports) != 0:
            self.add_line(Entity.port['open'])
            for index,(port_name,port) in enumerate(ports.items()):
                if index == len(ports) - 1:
                    self.add_line(port.get_line().replace(';',''))
                else:
                    self.add_line(port.get_line())

            self.add_line(Entity.port['end'])

        self.add_line(Entity.entity['end'].format(name = self.get_entity_name()))

        self.add_line(Entity.architecture['open'].format(name = name_placeholder))

        components = self.get_components()
        # component declarations
        if len(components) != 0:
            for component_name,(component,number_of_instances) in components.items():
                component_ports = component.get_ports()
                component_generics = component.get_generics()
                self.add_line(Entity.component['open'].format(name = component_name))

                # generics
                if len(component_generics) != 0:
                    self.add_line(Entity.generic['open'])
                    for index,(val_name,val_type) in enumerate(component_generics.values()):

                        if index == len(component_generics) - 1:
                            self.add_line(f'    {val_name} : {val_type}\n')
                        else:
                            self.add_line(f'    {val_name} : {val_type};\n')

                    self.add_line(Entity.generic['end'])

                if len(component_ports) != 0:  # skip if no ports
                    self.add_line(Entity.port['open'])

                    for index,(port_name,port) in enumerate(list(component_ports.items())):
                        if index == len(component_ports) - 1:
                            self.add_line(port.get_line().replace(';',''))
                        else:
                            self.add_line(port.get_line())

                    self.add_line(Entity.port['end'])

                self.add_line(Entity.component['end'].format(name = component_name))

        # signal declerations
        for component_name,(component,number_of_instances) in components.items():
            component_ports = component.get_ports()
            self.add_line(f'  -- {component_name}\n')
            for port_name, port in component_ports.items():

                # the declared signals are ordered in a way that only the outputs for each block are declared
                if (port_name not in self.__declared_signals) and (port.get_direction() == 'out'):
                    if type(port.get_length()) == type(1):
                        s1 = f'  signal {port_name} : std_logic_vector({port.get_length()-1} downto 0);\n'
                    else:
                        s1 = f'  signal {port_name} : {port.get_length()};\n'

                    s2 = f'  signal {port_name} : std_logic;\n'

                    if port.get_length() != 1:
                        self.add_line(s1)
                        self.__declared_signals.add(port_name)
                    else:
                        self.add_line(s2)
                        self.__declared_signals.add(port_name)


        # architecture begin
        self.add_line(Entity.architecture['begin'])

        # instantiations
        for component_name,(component,number_of_instances) in components.items():
            component_ports = component.get_ports()
            component_generics = component.get_generics()
            if len(component_ports) != 0:
                if number_of_instances != 0:
                    for i in range(number_of_instances):
                        # {instance name} : {component to instance}
                        self.add_line(Entity.instance['open'].format(i_name = f'{component_name}_{i}_i', e_name = component_name))

                        # generic mapping
                        if len(component_generics) != 0:
                            self.add_line(Entity.generic['map'])
                            for index, (val_name,val_type) in enumerate(list(component_generics.values())):
                                s = Entity.instance['map'].format(i_port = val_name, connect_to = 'open')
                                if index == len(component_generics) - 1:
                                    self.add_line(s.replace(',',''))
                                else:
                                    self.add_line(s)

                            self.add_line(Entity.generic['end'])
                        # port mapping
                        self.add_line(Entity.port['map'])
                        for index,(port_name,port) in enumerate(list(component_ports.items())):
                            # {instance_port} => {signal/port}
                            if 'out' in port.get_line():
                                s = Entity.instance['map'].format(i_port = port_name, connect_to = port_name)
                            else:
                                s = Entity.instance['map'].format(i_port = port_name, connect_to = 'open')

                            if index == len(component_ports) - 1:
                                self.add_line(s.replace(',',''))
                            else:
                                self.add_line(s)


                        self.add_line(Entity.instance['end'])

                        print(f"{component_name}_{i}_i instanced!")

        self.add_line(Entity.architecture['end'])

    def show_code(self):
        print(self.get_code())

    def show_components(self):
        print(f"\nDeclared components :\n")
        for component,instances in self.__components.values():
            s = f' {component.get_entity_name()}, {instances} instances'
            print(s)
        print('')

    def clear_code(self):
        self.__vhdl_code = []

    def generate_code(self, name = None):
        if name == None:
            fname = self.__entity_name + '.vhd'
        else:
            fname = name + '.vhd'

        complete_path = os.path.join(Entity.directory, fname)
        self.__build_code(name)

        if not self.__check_file(complete_path):
            with open(complete_path, mode = 'w') as file:
                file.write(self.get_code())
        else:
            print(f'Failed to generate code : file \'{fname}\' already exists...')

    def __check_file(self,path):
        file = Path(path)
        return file.is_file()




# print(__name__)
